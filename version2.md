# 0.6 file attachments

_expo image picker_ & _expo document picker_
added new type Attachment

Как это работает:
При создании/редактировании задачи можно выбрать изображения из галереи или документы (PDF и др.)
Файлы сохраняются в кэш приложения, URI сохраняются в AsyncStorage вместе с задачей
В списке задач видно количество прикрепленных файлов
В деталях задачи можно открыть любой файл

# 0.7 attachments handilng

_Linking.openURL()_
оказывается он не открывает local uri файлы, поэтому использую
_expo-sharing_
также используется _expo-file-system_ для корректной работы с файлами
для работы с Android используется _expo-intent-launcher_ для прямомого открытия через системные приложения
else если не работает, то через _Sharing API_ - "открыть с помощью"

# 0.8 Due date enahcned & notifications

Due date is now up to minutes, not only the days

_expo-notifications_ installed
lib/notifications.ts created

- requestNotificationPermissions() — запрос разрешений
- scheduleTaskNotification() — планирование уведомления за 30 минут до дедлайна
- cancelTaskNotification() — отмена уведомления для задачи
- rescheduleAllTaskNotifications() — перепланирование всех уведомлений

При создании задчаи автоматически планируется уведомление, при удалении отменяется
При изменении статуса на completed или cancelled уведомление останется

# 0.9 Geolocation & Maps

location.ts — функции для геолокации:
requestLocationPermissions() — запрос разрешений
getCurrentPositionAsync() — получение текущей позиции
reverseGeocodeAsync() — преобразование координат в адрес

1. expo-maps (v0.12.8)
   Нативные карты (Apple Maps на iOS, Google Maps на Android)
   Где используется: LocationPicker.tsx и map.tsx
   Проблема: не работает в Expo Go, нужна нативная сборка

2. react-native-webview (v13.16.0)
   Отображение веб-контента (HTML/JS) внутри приложения
   Где используется: LocationPicker.tsx (fallback когда expo-maps недоступен)
   Как работает: загружает HTML с картой Leaflet

3. Leaflet (через CDN, не npm пакет)
   Интерактивная веб-карта (OpenStreetMap)
   Где используется: внутри HTML в LocationPicker.tsx (в WebView)
   Как работает: загружается через CDN в HTML-странице
   Особенности:
   Работает в Expo Go
   Не требует API ключа
   Можно кликать и перетаскивать маркер
   Как это работает вместе
   Если expo-maps доступен (development build):
   Используется нативная карта через MapView и Marker
   Если expo-maps недоступен (Expo Go):
   Используется WebView с HTML-страницей
   В HTML загружается Leaflet через CDN
   Leaflet показывает карту OpenStreetMap
   Координаты передаются через postMessage из WebView в React Native

# 1.0 History page added

The logs of the app are now shwon in a beautiful way in the history page

# 1.1 Dark Theme

1. Store для темы (lib/themeStore.ts)
   Использовали Zustand с persist (сохранение в AsyncStorage)
   Храним themeMode: 'light' | 'dark'
   Методы: toggleTheme() и setThemeMode()
   Выбор темы сохраняется и восстанавливается при следующем запуске
2. Опредление цвета тем (lib/theme.ts)
   Светлая тема: светлые фоны, темный текст
   Темная тема: темные фоны, светлый текст
   Цвета для статусов (todo, in_progress, completed, cancelled) для обеих тем
   Использовали MD3LightTheme и MD3DarkTheme из react-native-paper как базу
3. Обновленный Root Layout
   Подключена useThemeStore() для получения текущей темы
   Динамически выбирается lightTheme или darkTheme
   Тема передается в PaperProvider — все компоненты react-native-paper используют её
   Заголовки экранов обновляются через функции в options={() => ({...})}
4. UI переключатель добавлен в хедер
   Switch справа в хедере
   Подключен к toggleTheme() из store
   При переключении тема меняется во всем приложении
5. Обновилены все экраны
   Заменили хардкодные цвета на theme.colors.\* через useTheme()
   Обновили компоненты:
   new.tsx — форма создания задачи
   edit/[id].tsx — форма редактирования
   task/[id].tsx — детали задачи
   history.tsx — история действий
   map.tsx — карта с задачами
   index.tsx — главный экран (уже был обновлен)

   _Как это работает:_
   Пользователь переключает Switch → вызывается toggleTheme()
   Store обновляет themeMode и сохраняет в AsyncStorage
   \_layout.tsx получает новую тему из store
   PaperProvider передает новую тему всем компонентам
   Компоненты с useTheme() получают новые цвета и перерисовываются
   Все экраны автоматически обновляются
   Преимущества подхода:
   Централизованное управление — одна тема для всего приложения
   Персистентность — выбор сохраняется
   Автоматическое обновление — все компоненты Paper используют тему
   Легко расширять — можно добавить больше тем или настроек
   Итог: переключатель в хедере меняет тему для всего приложения, выбор сохраняется, и все экраны автоматически адаптируются.

# 1.2 Proxy Fix

При передачи task из Proxy в scheduleTaskNotification, а затем обращении к task.datetime, Proxy мог стать невалидным (handler = null), что вызывало ошибку.

# 1.3 Offline support

Основная идея
Приложение работает офлайн: все операции сохраняются локально, а синхронизация с сервером происходит автоматически при восстановлении интернета.

Архитектура

1. Локальное хранилище (AsyncStorage)
   Все задачи сохраняются локально через Zustand persist
   Работает без интернета
   Данные не теряются при перезапуске
2. Очередь синхронизации (pendingSync)
   При создании/изменении/удалении задачи операция добавляется в очередь pendingSync
   Каждая операция содержит:
   Тип: create, update, delete
   ID задачи
   Данные задачи (для create/update)
   Счетчик попыток (retries)
3. Автоматическая синхронизация
   При старте приложения: если есть интернет и есть pending операции → запускается синхронизация
   При восстановлении интернета: NetInfo отслеживает изменения сети → при переходе из offline в online запускается синхронизация
4. Процесс синхронизации
   1. Проверка доступности API сервера
   2. Если сервер доступен → выполняем операции из очереди последовательно
   3. При успехе → удаляем операцию из очереди
   4. При ошибке → увеличиваем retries, операция остается в очереди
   5. Максимум 3 попытки для каждой операции
5. Retry-логика
   Если операция не удалась и retries < 3 → увеличиваем счетчик, операция остается в очереди
   При следующей синхронизации попытка повторяется
   Если retries >= 3 → операция удаляется из очереди (превышен лимит)
6. Визуальная индикация
   Индикатор в header показывает:
   Количество pending операций
   Статус синхронизации (syncing/success/error)
   Кнопка "Retry" для ручного запуска

7. Поток данных
   _Создание задачи:_
   addTask() → Сохранить локально в AsyncStorage → Добавить операцию в pendingSync → (Если есть интернет) → Автосинхронизация
   _Офлайн режим:_
   addTask() → Сохранить локально → Добавить в pendingSync → (Нет интернета) → Ждем восстановления\*
   _Восстановление интернета:_
   NetInfo обнаруживает изменение → syncTasks() → Проверка API → Выполнение операций из очереди → Удаление успешных операций
